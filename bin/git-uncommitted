#!/bin/sh

_commands() {
  {
    git -C "$1" update-index -q --refresh | sed 's/^/update-index:/g'
    git -C "$1" diff-index --name-only HEAD -- | sed 's/^/diff-index:/g'
    git -C "$1" status -sb | grep "\[ahead " | sed 's/^/status:/g'
    git -C "$1" ls-files --other --exclude-standard | sed 's/^/ls-files:/g'
    git -C "$1" branch --show-current | grep -v -E 'main|master' | sed 's/^/branch:/g'
  } | cut -d ":" -f 1 | sort -u | sed "s#^#$1 (#g" | sed 's/$/)/g'
}

IS_PWD=0
if [ -n "$1" ]; then
  if [ "$1" = "--pwd" ]; then
    IS_REV=$(git -C "$PWD" rev-parse --is-inside-work-tree 2>/dev/null)
    if [ "$IS_REV" = "true" ]; then
      RESULT=$(_commands "$PWD")
    else
      exit 0
    fi
    IS_PWD=1
  fi
fi
if [ "$IS_PWD" -eq 0 ]; then
  REPOS=""
  for DIR in $HOME/Git $HOME/Workspace; do
    for SUB in "$DIR"/*; do
      if [ ! -d "$SUB/.git" ]; then
        continue
      fi
      REPOS="$REPOS $SUB"
    done
  done
  for SUB in $REPOS; do
    SUBRES=$(_commands "$SUB")
    if [ -z "$RESULT" ]; then
      RESULT="$SUBRES"
    else
      RESULT=$(printf "%s\n%s\n" "$RESULT" "$SUBRES")
    fi
  done
fi
RESULT=$(echo "$RESULT" | sed 's/^\s*//g' | sed  's/\s*$//g')
HAS=0
if [ -n "$RESULT" ]; then
  HAS=1
fi
if [ -z "$1" ]; then
  if [ -n "$RESULT" ]; then
    echo "$RESULT" | sed "s#//#/#g"
  fi
else
  case "$1" in
  "--pwd")
    if [ "$HAS" -eq 0 ]; then
      printf '\e[32m%s\e[0m' "(clean)"
    else
      printf '\e[31m%s\e[0m' "(dirty)"
    fi
    ;;
  "--quiet")
      ;;
  *)
    echo "unknown subcommand"
    exit 1
    ;;
  esac
fi
exit "$HAS"
