#!/usr/bin/env perl
use strict;
use warnings;
use threads;
use Cwd;
use Thread::Queue;
use File::Spec::Functions 'catfile';

sub tracked {
    my $path = $_[0];
    if ( index( $path, ".env" ) != -1 ) {
        return 1;
    }
    my $tracking = `git -C "$path" config --list | grep 'user\.email' 2>&1`;
    $tracking =~ s/^\s+|\s+$//g;
    if ($tracking) {
        return 1;
    }
    return 0;
}

my $arg  = "";
my $args = $#ARGV + 1;
my @paths;
my $is_pwd = 0;
$args == 1 or $args == 0 or die("invalid arguments");
if ( $args == 1 ) {
    $arg = $ARGV[0];
    $arg eq "--pwd" or die("unknown argument: $arg");
    $is_pwd = 1;
    my $wd    = getcwd();
    my $isrev = `git -C "$wd" rev-parse --is-inside-work-tree 2>/dev/null`;
    $isrev =~ s/^\s+|\s+$//g;
    if ( $isrev ne "true" or not tracked($wd) ) {
        exit(0);
    }
    push( @paths, $wd );
}
if ( not $is_pwd ) {
    my @targets;
    push( @targets, ".env" );
    push( @targets, "workspace" );
    push( @targets, "OTHER" );
    my $home = $ENV{"HOME"};
    if ( not $home ) {
        die("unable to get home");
    }
    for my $target (@targets) {
        my $pathing = catfile( $home, $target );
        if ( not -d $pathing ) {
            next;
        }
        my $handle;
        opendir( $handle, $pathing );
        my @files = readdir($handle);
        closedir($handle);

        foreach my $file (@files) {
            next if ( $file =~ /^\.$/ );
            next if ( $file =~ /^\.\.$/ );
            my $path_to = catfile( $pathing, $file );
            if ( not -d catfile( $path_to, ".git" ) ) {
                next;
            }
            push( @paths, $path_to );
        }
    }
}

sub uncommit {
    my $arg = $_[0];
    if ( not tracked($arg) ) {
        return "";
    }
    my @commands;
    my $git          = "git -C '$arg'";
    my $update_index = `$git update-index -q --refresh 2>&1`;
    if ($update_index) {
        $update_index = "update-index";
    }
    push( @commands, "diff-index:$git diff-index --name-only HEAD --" );
    push( @commands, "status:$git status -sb | grep '\\[ahead '" );
    push( @commands, "ls-files:$git ls-files --other --exclude-standard" );
    push( @commands,
        "branch:$git branch --show-current | grep -v -E '^(main|master)\$'" );

    my $procs = scalar(@commands);
    my @runners;

    my $in = Thread::Queue->new();
    $in->limit = $procs;
    my $out = Thread::Queue->new();
    $out->limit = $procs;

    my $spawning = $procs;
    while ( $spawning >= 0 ) {
        push(
            @runners,
            threads->create(
                sub {
                    while ( defined( my $item = $in->dequeue() ) ) {
                        my @items = split( ":", $item );
                        my $cmd   = join( ":", @items[ 1 .. $#items ] );
                        my $res   = `$cmd 2>&1`;
                        if ($res) {
                            $res = "$items[0]";
                        }
                        $out->enqueue($res);
                    }
                }
            )
        );
        $spawning -= 1;
    }

    for my $cmd (@commands) {
        $in->enqueue($cmd);
    }
    $in->end();

    my @has;
    while ( $out->pending() != $procs ) { }
    $out->end();
    my $more = 1;
    while ($more) {
        if ( $out->pending() ) {
            my $nxt = $out->dequeue();
            if ($nxt) {
                push( @has, $nxt );
            }
        }
        else {
            last;
        }
    }

    for my $runner (@runners) {
        $runner->join();
    }
    push( @has, $update_index );
    my $all = join( " ", @has );
    $all =~ s/^\s+|\s+$//g;
    return $all;
}

for my $path (@paths) {
    my $res = uncommit($path);
    if ($is_pwd) {
        if ($res) {
            print "\e[31m(dirty)\e[0m";
        }
        else {
            print "\e[32m(clean)\e[0m";
        }
        last;
    }
    if ($res) {
        for my $warn ( split( " ", $res ) ) {
            print "$path ($warn)\n";
        }
    }
}
