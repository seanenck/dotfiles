#!/usr/bin/env bash
if [ -z "$1" ]; then
  echo "no subcommand given"
  exit 1
fi

_all() {
  local f code
  code=0
  for f in git jj; do
    if ! uncommitted "$f" $@; then
      code=1
    fi
  done
  exit $code
}

MODE="$1"
case "$1" in
  "git")
    ;;
  "jj")
    ;;
  "all")
    _all ${@:2}
    ;;
  *)
    echo "unknown command: $1"
    exit 1
esac

_git-uncommit() {
  local result
  result=$(git -C "$1" ${@:2})
  if [ -n "$result" ]; then
    echo "uncommit:$1,$2,$result"
  fi
}

_git-commands() {
  {
    _git-uncommit "$1" update-index -q --refresh
    _git-uncommit "$1" diff-index --name-only HEAD --
    _git-uncommit "$1" status -sb | grep "\[ahead "
    _git-uncommit "$1" ls-files --other --exclude-standard
    _git-uncommit "$1" branch --show-current | grep -v -E ',(main|master)$'
  } | grep '^uncommit:' | cut -d ':' -f 2- | cut -d ',' -f 1,2 | sed 's/,/ (/g' | sed 's/$/)/g' | sort -u
}

_jj-commands() {
  {
    if jj -R "$1" status | grep -v -E "^(Parent commit|Working copy ):" | grep -v '^The working copy is clean$' > /dev/null 2>&1; then
      echo "$1 (status)"
    fi
    if jj -R "$1" branch list | grep -E "(behind|ahead) by" | grep -q "commits"; then
      echo "$1 (commits)"
    fi
  }
}

uncommit() {
  local res d sub has r ispwd isrev paths
  ispwd=0
  if [ -n "$1" ]; then
    if [ "$1" == "--pwd" ]; then
      case "$MODE" in
        "git")
          isrev=$(git -C "$PWD" rev-parse --is-inside-work-tree 2>/dev/null)
          if [ "$isrev" == "true" ]; then
            res=$(_git-commands "$PWD")
          else
            exit 0
          fi
          ;;
        "jj")
          if ! jj -R "$PWD" status >/dev/null 2>&1; then
            exit 0
          fi
          res=$(_jj-commands "$PWD")
      esac
      ispwd=1
    fi
  fi
  if [ "$ispwd" -eq 0 ]; then
    paths=""
    for d in .env workspace; do
      d="$HOME/$d"
      for sub in "$d"/*; do
        if [ ! -d "$sub/.$MODE" ]; then
          continue
        fi
        paths="$paths $sub"
      done
    done
    for sub in $paths; do
      case "$MODE" in
        "git")
          r=$(_git-commands "$sub")
          ;;
        "jj")
          r=$(_jj-commands "$sub")
          ;;
      esac
      if [ -z "$res" ]; then
        res=$r
      else
        res=$(printf "%s\n%s\n" "$res" "$r")
      fi
    done
  fi
  res=$(echo "$res" | sed 's/^\s*//g' | sed  's/\s*$//g')
  has=0
  if [ -n "$res" ]; then
    has=1
  fi
  if [ -z "$1" ]; then
    if [ -n "$res" ]; then
      echo "$res"
    fi
  else
    case "$1" in
    "--pwd")
      if [ $has -eq 0 ]; then
        printf '\e[32m%s\e[0m' "(clean)"
      else
        printf '\e[31m%s\e[0m' "(dirty)"
      fi
      ;;
    "--quiet")
        ;;
    *)
      echo "unknown subcommand"
      exit 1
      ;;
    esac
  fi
  exit $has
}

uncommit "$2"
